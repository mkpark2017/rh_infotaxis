#include "rh_infotaxis/ParticleFilter.h"


void ParticleFilter::initialization(int num_particles, EnvClass env) //constructor
{
    std::random_device rd;  // Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<double> rand_data(0.0, 1.0);

    n_p = num_particles;
    for(int i=0; i<n_p; i++)
    {
        
        X.push_back( rand_data(gen)*env.nx );
        Y.push_back( rand_data(gen)*env.ny );
        Z.push_back( rand_data(gen)*env.nz );
        
        /*
        X.push_back( rand_data(gen)*12 );
        Y.push_back( rand_data(gen)*12 );
        Z.push_back( rand_data(gen)*24 );
        */
        Q.push_back( rand_data(gen)*env.source_q );
        Phi.push_back( rand_data(gen)*env.source_phi );
        D.push_back( rand_data(gen)*env.source_d );
        Tau.push_back( rand_data(gen)*env.source_tau );

        Wpnorm.push_back( 1.0/n_p );

        exp_conc.push_back(0.0);
        ga_new.push_back(0.0);

    }

}

void ParticleFilter::isotropic_plume(UavClass uav, EnvClass env)
{
    double dist, y_n, lambda_plume, rate;

    for(int i=0; i<n_p; i++)
    {
        dist = sqrt( pow(uav.x-X[i],2) + pow(uav.y-Y[i],2) + pow(uav.z-Z[i],2) ) * env.m_per_grid;
        y_n = ( -(uav.x-X[i])*sin(Phi[i]) + (uav.y-Y[i])*cos(Phi[i]) ) * env.m_per_grid;
        lambda_plume = sqrt( D[i]*Tau[i] / (1+pow(env.source_u,2)*Tau[i]/4/D[i]) );
        rate = Q[i]/(4*M_PI*D[i]*dist) * exp(-y_n*env.source_u/(2*D[i]) - dist/lambda_plume);
        exp_conc[i] = rate * env.dt * (3*3); //horizontal size = 3m X 3m, vertical size = 1m

        //std::cout << exp_conc[i] << "  ";
    }
    //std::cout << std::endl;

}

vector<bool> ParticleFilter::prior(EnvClass env, vector<double> pf_samples)
{
    vector<double> pf_x(pf_samples.begin(),       pf_samples.begin()+n_p),
                   pf_y(pf_samples.begin()+n_p,   pf_samples.begin()+n_p*2),
                   pf_z(pf_samples.begin()+n_p*2, pf_samples.begin()+n_p*3),
                   pf_q(pf_samples.begin()+n_p*3, pf_samples.begin()+n_p*4),
                   pf_p(pf_samples.begin()+n_p*4, pf_samples.begin()+n_p*5),
                   pf_d(pf_samples.begin()+n_p*5, pf_samples.begin()+n_p*6),
                   pf_t(pf_samples.begin()+n_p*6, pf_samples.end());

    vector<bool> keep;
    for(int i=0; i<n_p; i++)
    {
        keep.push_back(0); // Set false
        if(pf_x[i]>=0 && pf_x[i]<=env.nx){
            if(pf_y[i]>=0 && pf_y[i]<=env.ny){
                if(pf_z[i]>=0 && pf_z[i]<=env.nz){
                    if(pf_[i]>=0.01*env.source_q && D[i]>=0 && Tau[i]>=0){
                       keep.push_back(1); // Keep true
                    }
                }
            }
        }
    }
    return keep;
}

void ParticleFilter::resampling(UavClass uav, EnvClass env)
{
    std::random_device rd;  // Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<double> rand_data(0.0, 1.0);


    double sum_weight[n_p] = {0,}, random_select[n_p];
    sum_weight[0] = Wpnorm[0];
    random_select[0] = rand_data(gen)/n_p;
    for(int i=1; i<n_p; i++)
    {
        sum_weight[i] = sum_weight[i-1] + Wpnorm[i];
        random_select[i] = double(i)/n_p + rand_data(gen)/n_p;
        //std::cout << "WP: " << Wpnorm[i] << std::endl;
        //std::cout << "SUM: " << sum_weight[i] << std::endl;
        std::cout << random_select[i] << std::endl;
    }
    int j =0;
    std::vector<int> indx;
    for(int i=0; i<n_p; i++)
    {
        while(sum_weight[j] < random_select[i])
        {
            j += 1;
        }
        indx.push_back(j);

        std::cout << "indx: " << indx[i] << std::endl;
    }

    //----------------------------------MCMC------------------------------------
    double mm=5.0;
    double A=pow(4.0/(mm+2.0), 1.0/(mm+4.0) );
    double hopt = A* pow(n_p, -1.0/(mm+4.0) );

    for(int i=0; i<n_p; i++)
    {
        X[i] = X[indx[i]];
        Y[i] = Y[indx[i]];
        Z[i] = Z[indx[i]];

        Q[i]   = Q[indx[i]];
        Phi[i] = Phi[indx[i]];
        D[i]   = D[indx[i]];
        Tau[i] = Tau[indx[i]];
    }

    std::vector<int> indx_unique;
    indx_unique = indx;
    indx_unique.erase(unique(indx_unique.begin(), indx_unique.end() ), indx_unique.end() );

    double num_while_iter = 1.0;
    
    while(indx_unique.size() < n_p*0.5)
    {
        double dkX, dkY, dkZ, dkQ, dkPhi, dkD, dkTau;

        //------------------------------------------STD-----------------------------------------
        dkX = sqrt( (X*X).sum()/X.size() - pow(X.sum()/X.size(),2) )/num_while_iter + 0.5;
        dkY = sqrt( (Y*Y).sum()/Y.size() - pow(Y.sum()/Y.size(),2) )/num_while_iter + 0.5;
        dkZ = sqrt( (Z*Z).sum()/Z.size() - pow(Z.sum()/Z.size(),2) )/num_while_iter + 0.5;

        dkQ   = sqrt( (Q*Q).sum()/Q.size() - pow(Q.sum()/Q.size(),2) )/num_while_iter + 0.5;
        dkPhi = sqrt( (Phi*Phi).sum()/Phi.size()-pow(Phi.sum()/Phi.size(),2) )/num_while_iter+0.5;
        dkD   = sqrt( (D*D).sum()/D.size() - pow(D.sum()/D.size(),2) )/num_while_iter + 0.5;
        dkTau = sqrt( (Tau*Tau).sum()/Tau.size()-pow(Tau.sum()/Tau.size(),2) )/num_while_iter+0.5;

        vector<double> nX, nY, nZ, nQ, nPhi, nD, nTau;

        for(int i=0; i<n_p; i++)
        {
            nX.push_back( X[i] + hopt * dkX * rand_data(gen) );
            nY.push_back( Y[i] + hopt * dkY * rand_data(gen) );
            nZ.push_back( Z[i] + hopt * dkZ * rand_data(gen) );

            nQ.push_back(   Q[i]   + hopt * dkQ   * rand_data(gen) );
            nPhi.push_back( Phi[i] + hopt * dkPhi * rand_data(gen) );
            nD.push_back(   D[i]   + hopt * dkD   * rand_data(gen) );
            nTau.push_back( Tau[i] + hopt * dkTau * rand_data(gen) );
        }
        isotropic_plume(uav, env);

        double ndetSig[n_p], na_val[n_p] na_new[n_p];
        for(int i=0; i<n_p; i++)
        {
            ndetSig[i] = sqrt( pow(exp_conc[i]*uav.sensor_sig_m,2) + pow(env.env_sig,2) );
            if(ndetSig[i] < 1e-100)
                ndetSig[i] = 1e-100;

            na_val[i] = (uav.sensor_value - exp_conc[i]) / ndetSig[i];
            na_new[i] = 1/(sqrt(2*M_PI) * ndetSig[i]) * exp(-pow(na_val[i],2) / 2);
        }

        //----------------------------make single vecotr-----------------------------------
        vector<double> pf_samples = X;
        pf_samples.insert(pf_samples.end(), Y.begin(), Y.end());
        pf_samples.insert(pf_samples.end(), Z.begin(), Z.end());

        pf_samples.insert(pf_samples.end(), Q.begin(),   Q.end());
        pf_samples.insert(pf_samples.end(), Phi.begin(), Phi.end());
        pf_samples.insert(pf_samples.end(), D.begin(),   D.end());
        pf_samples.insert(pf_samples.end(), Tau.begin(), Tau.end());

        vector<bool> indx;
        indx = prior(env, );
    }
    
}

void ParticleFilter::weight_update(UavClass uav, EnvClass env)
{
    isotropic_plume(uav, env);

    double pdetSig[n_p], ga_val[n_p];
    for(int i=0; i<n_p; i++)
    {
        pdetSig[i] = sqrt( pow(exp_conc[i]*uav.sensor_sig_m,2) + pow(env.env_sig,2) );
        if(pdetSig[i] < 1e-100)
	    pdetSig[i] = 1e-100;

        ga_val[i] = (uav.sensor_value - exp_conc[i]) / pdetSig[i];
        ga_new[i] = 1/(sqrt(2*M_PI) * pdetSig[i]) * exp(-pow(ga_val[i],2) / 2);
        
        std::cout << "-------------------------------------------" << std::endl;
        std::cout << "Wp_origin: " << Wpnorm[i] << std::endl;
        std::cout << "Exp_conc: " << exp_conc[i] << std::endl;
        std::cout << "likelihood: " << ga_new[i] << std::endl;
        
        Wpnorm[i] = Wpnorm[i]*ga_new[i];

        /*
        std::cout << "Wp_new: " << Wpnorm[i] << std::endl;
        */
    }

    //----------------------------make single vecotr-----------------------------------
    vector<double> pf_samples = X;
    pf_samples.insert(pf_samples.end(), Y.begin(), Y.end());
    pf_samples.insert(pf_samples.end(), Z.begin(), Z.end());

    pf_samples.insert(pf_samples.end(), Q.begin(),   Q.end());
    pf_samples.insert(pf_samples.end(), Phi.begin(), Phi.end());
    pf_samples.insert(pf_samples.end(), D.begin(),   D.end());
    pf_samples.insert(pf_samples.end(), Tau.begin(), Tau.end());


    vector<int> indx;
    indx = prior(env, pf_samples); // check particles out of domain

    for(int i=0; i<n_p; i++)
    {
        if(indx[i] == 0)
        {
            Wpnorm[i] = 0;
        }
    }

    double Wp_sum = 0, Neff_inv = 0;
    for(int i=0; i<n_p; i++)
    {
        Wp_sum += Wpnorm[i];
    }
    for(int i=0; i<n_p; i++)
    {
        Wpnorm[i] = Wpnorm[i]/Wp_sum;
        std::cout << "Wp_new: " << Wpnorm[i] << std::endl;

        Neff_inv += pow(Wpnorm[i],2);
        /*
        std::cout << "Wp_new: " << Wpnorm[i] << std::endl;
        std::cout << Wp_sum << std::endl;
        std::cout << Neff_inv << std::endl;
        */
    }
    /*
    std::cout << 1.0/Neff_inv << std::endl;
    std::cout << 0.5*n_p << std::endl;
    */

    if(1.0/Neff_inv < 1.0*n_p)
    {
        resampling(uav, env);
    }
    /*
    std::cout << "X: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<X[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "Y: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<Y[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "Z: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<Z[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "Q: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<Q[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "Phi: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<Phi[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "D: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<D[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "Tau: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<Tau[i] << "; ";
    }
    std::cout << std::endl;
    std::cout << "Exp_conc: ";
    for(int i=0; i<n_p; i++)
    {
        std::cout <<exp_conc[i] << "; ";
    }
    std::cout << std::endl;
    */



}

