#include "rh_infotaxis/LidarMap.h"

void LidarMap::initialization(double grid_x, double grid_y, double grid_z, double grid_resolution)
{
    for(int i=0; i<grid_x; i++)
    {
        vector<int8_t> grid_map_1d;
        for(int j=0; j<grid_y; j++)
        {
            grid_map_1d.push_back(50);
        }
        grid_map.push_back(grid_map_1d);
    }

    resolution = grid_resolution;
    updated = true;
}

void LidarMap::lidar_uav_pose_update(UavClass sensing_uav)
{
    uav_x = (sensing_uav.x/resolution)-1;
    uav_y = (sensing_uav.y/resolution)-1;
    uav_z = (sensing_uav.z/resolution)-1;
}

void LidarMap::callback(const sensor_msgs::LaserScan::ConstPtr& msg)
{
    if(trigger)
    {

        float a_min = (msg->angle_min) / 180 * M_PI;
        float a_max = (msg->angle_max) / 180 * M_PI;
        float a_gap = (msg->angle_increment) / 180 * M_PI;
        //float r_min = msg->range_min;
        float r_max = msg->range_max;
        int laser_num = (a_max-a_min)/a_gap;

        float ranges[laser_num];

cout<< "lidar_num" << laser_num << endl;

        for(int i=0; i<laser_num; i++)
        {
            ranges[i] = round((msg->ranges[i])/resolution); //do i have to round it?
            double laser_angle = a_min + a_gap*i;
	    double grid_x, grid_y;
            for(int j=0; j<=ranges[i]; j++)
            {
                grid_x = round(uav_x + cos(laser_angle)*(j+0.1) );
                grid_y = round(uav_y + sin(laser_angle)*(j+0.1) );
                if(j==ranges[i] && ranges[i] < round(r_max/resolution) && grid_x != 0 && grid_y != 0)
                    grid_map[grid_y][grid_x] = 100;
                else
                    grid_map[grid_y][grid_x] = 0;

                //cout<< i << "  cos(angle): " << cos(laser_angle) << endl;
            }
        }
        trigger = false; // turn off the trigger
        updated = true;
    }
}
