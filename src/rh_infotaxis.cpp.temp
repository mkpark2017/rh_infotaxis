#include "rh_infotaxis/ParticleFilter.h"
#include "rh_infotaxis/EnvClass.h"
#include "rh_infotaxis/UavClass.h"
#include "rh_infotaxis/LidarMap.h"
/*--------------------------*/
//#include <stdr_msgs/AddCO2Source.h>
#include <std_srvs/SetBool.h>
#include <sensor_msgs/LaserScan.h>
#include <nav_msgs/OccupancyGrid.h>
#include <std_msgs/Bool.h>
#include <geometry_msgs/PoseStamped.h>
/*--------------------------*/
#include <ros/ros.h> //ALWAYS need to include this
#include <iostream> // cout
#include <string> // std::stod = string to double

using namespace std;

EnvClass env;
ParticleFilter pf;
UavClass current_uav;
UavClass sensing_uav;
UavClass next_goal;
void currentPoseCallback(const geometry_msgs::PoseStamped::ConstPtr& msg)
{
    current_uav.x = msg->pose.position.x;
    current_uav.y = msg->pose.position.y;
    current_uav.z = msg->pose.position.z;
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "test");
    ros::NodeHandle n;

    double source[8], domain[5];
    n.param("source_x",   source[0], 204.0);
    n.param("source_y",   source[1], 210.0);
    n.param("source_z",   source[2], 11.0);
    n.param("source_u",   source[3], 3.0);
    n.param("source_q",   source[4], 7.2*1000*1000/60/60); //  7.2kg/h = 2000mg/s
    n.param("source_phi", source[5], 290*M_PI/180);
    n.param("source_d",   source[6], 10.0);
    n.param("source_tau", source[7], 1000.0);

    n.param("nx",         domain[0], 270.0);
    n.param("ny",         domain[1], 270.0);
    n.param("nz",         domain[2], 45.0);
    n.param("dt",         domain[3], 1.0);
    n.param("env_sig",    domain[4], 2.0);
    env.initialization(source, domain);

    double sen_param[3];
    n.param("sen_sig_m", sen_param[0], 0.1);
    n.param("sen_h_range", sen_param[1], 3.0);
    n.param("sen_v_range", sen_param[2], 1.0);
    sensing_uav.initialization(sen_param);

    int num_particle = 10;
    pf.initialization(num_particle, env);

    //---------------------------conduct measurement receive service----------------------------
    //----------------when service call true, server return current sensor data-----------------
    ros::ServiceClient gas_sen_client = n.serviceClient<std_srvs::SetBool>("/gas_sen_svc");
    std_srvs::SetBool sen_srv;
    double uav_conc = 0;
    int sensing_iter = 0;
    double uav_pose[3] = {0, 0, 0};
    //---------------------------------------current pose sub------------------------------
    ros::Subscriber current_pose_sub = n.subscribe("/mavros/local_position/pose", 1000, currentPoseCallback);
    //----------------------------------------lidar scan sub---------------------------------------
    double grid_resolution;
    n.param("grid_map_resolution", grid_resolution, 3.0);
    int32_t grid_x = domain[0]/grid_resolution;
    int32_t grid_y = domain[1]/grid_resolution;
    int32_t grid_z = domain[2]/grid_resolution;
    LidarMap lidar_map(grid_x, grid_y, grid_z, grid_resolution);
    ros::Subscriber lidar_map_sub = n.subscribe("/lidar_2d", 1000, &LidarMap::callback, &lidar_map);
    //-----------------------------------------lidar map pub----------------------------------------
    ros::Publisher map_2d_pub = n.advertise<nav_msgs::OccupancyGrid>("/map_2d", 1000);
    nav_msgs::OccupancyGrid map_2d_msg;
    map_2d_msg.info.resolution = grid_resolution; // 1m/cell
    map_2d_msg.info.width = grid_x;
    map_2d_msg.info.height = grid_y;
    //----------------------------------------next goal pub---------------------------------------
    ros::Publisher next_goal_pub = n.advertise<geometry_msgs::PoseStamped>("/mavros/setpoint_position/local", 1000);
    geometry_msgs::PoseStamped next_goal_msg;
    double goal_ep;
    n.param("goal_epsilon", goal_ep, 0.1);

    next_goal.x = 6.0; //temp
    next_goal.y = 6.0; //temp
    next_goal.z = 12.0; //temp
    next_goal_msg.pose.position.x = next_goal.x; //temp
    next_goal_msg.pose.position.y = next_goal.y; //temp
    next_goal_msg.pose.position.z = next_goal.z; //temp


    ros::Rate loop_rate(10); // 10Hz

    vector<int8_t> current_map;

    while(ros::ok())
    {
        double del_x_sq = pow(next_goal.x-current_uav.x,2);
        double del_y_sq = pow(next_goal.y-current_uav.y,2);
        double del_z_sq = pow(next_goal.z-current_uav.z,2);
        double goal_dist = sqrt(del_x_sq + del_y_sq + del_z_sq);
        // -------------------------Trigger to get measurement-----------------------
        if(goal_dist < goal_ep) // reaching goal
        {
            sen_srv.request.data = true;
            if(gas_sen_client.call(sen_srv) )
            {
                if(sen_srv.response.success) // in sensing time, success==true
                {
                    uav_pose[0] += current_uav.x;
                    uav_pose[1] += current_uav.y;
                    uav_pose[2] += current_uav.z;
                    uav_conc += std::stod(sen_srv.response.message); //string to double
                    sensing_iter += 1;
                }
                else //end sensing time = sen_srv.response.success = false
                {
                    uav_pose[0] = uav_pose[0]/sensing_iter; // taking average
                    uav_pose[1] = uav_pose[1]/sensing_iter;
                    uav_pose[2] = uav_pose[2]/sensing_iter;
                    uav_conc    = uav_conc/sensing_iter;
                    sensing_uav.state_update(uav_pose, uav_conc); // now sensing_uav.x is changed

                    //------------particle filter update-----------------------
                    pf.weight_update(sensing_uav, env);

                    //--------------lidar map update-----------------------
                    lidar_map.lidar_uav_pose_update(uav_pose[0], uav_pose[1], uav_pose[2]);
                    lidar_map.trigger = true; //then start map update
                    ros::spinOnce(); // run LidarMap::Callback function

                    //------------decision making (new goal)---------------
                    //next_goal = rh_infotaxis_decision_making(sensing_uav, pf, env);
                    next_goal_msg.pose.position.x = next_goal.x;
                    next_goal_msg.pose.position.y = next_goal.y;
                    next_goal_msg.pose.position.z = next_goal.z;

                    //------------------initialize------------------
                    uav_pose[0] = 0, uav_pose[1] = 0, uav_pose[2] = 0;
                    uav_conc = 0;
                    sensing_iter = 0;
                } // finish sensing + pf update + decision making

            } // finish sensor service response

        } // goal reached

        //-----------------------always publish target pose------------------------
        next_goal_pub.publish(next_goal_msg);
        //--------------------------------------------------------------------------
        //ROS_INFO("Sensor_data_obtaining_ready");
        //cout<<lidar_map.updated << endl;
        if(lidar_map.updated)
        {
            current_map.clear();
            for(int i=0; i<lidar_map.grid_map.size(); i++)
            {
                for(int j=0; j<lidar_map.grid_map[i].size(); j++)
                {
                    current_map.push_back(lidar_map.grid_map[i][j]);
                }
            }
            //cout << current_map[0] << endl;
            lidar_map.updated = false;
        }
        cout << current_map[0] << endl;
        map_2d_msg.data = current_map;
        map_2d_pub.publish(map_2d_msg);

        ros::spinOnce();
        //cout << "uav_x_now: " << uav.x << endl;;
        /*
        for (size_t i=0; i< pf.X.size(); i++)
        {
            cout << pf.X[i] << ";  ";
        }
        cout << endl;

        cout << env.source_x << endl;
        */
        loop_rate.sleep();
    }
    return 0;
}
